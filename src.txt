The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encounted. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
types.ts
// types.ts: Type definition
// Aug 2024 by Rino, eMotionGraphics Inc.

import { Item as OmnivoreItem, Highlight as OmnivoreHighlight } from '@omnivore-app/api';

export interface Article extends OmnivoreItem {
    hash?: string;
    createdAt?: string;
    readingProgressAnchorIndex?: number;
    folder?: string;
}

export interface Highlight extends OmnivoreHighlight {
    shortId?: string;
    createdAt?: string;
    article: {
        id: string;
        title: string;
        url: string;
        originalArticleUrl?: string;
        savedAt: string;
        author?: string;
        publishedAt?: string;
        slug?: string;
    };
}

export interface Label {
    id: string;
    name: string;
    color: string;
    description?: string;
}

export type ID = string;

export interface SyncedArticle {
    id: string;
    savedAt: string;
}

export interface SyncedHighlight {
    id: string;
    createdAt: string;
}

export enum SyncType {
    All = 'all',
    Articles = 'articles',
    Highlights = 'highlights'
}

export interface OmnivoreClientConfig {
    apiKey: string;
    baseUrl: string;
}

export interface Note {
    id: string;
    title: string;
    body: string;
}

----
logger.ts
// logger.ts
// Aug 2024 by Rino, eMotionGraphics Inc.

import joplin from 'api';

export enum LogLevel {
    ErrorOnly = 'error',
    ErrorsAndWarnings = 'warn',
    Debug = 'debug'
}

class Logger {
    private async getLogLevel(): Promise<LogLevel> {
        return await joplin.settings.value('logLevel') as LogLevel;
    }

    async error(...args: any[]): Promise<void> {
        console.error(...args);
    }

    async warn(...args: any[]): Promise<void> {
        const level = await this.getLogLevel();
        if (level === LogLevel.ErrorsAndWarnings || level === LogLevel.Debug) {
            console.warn(...args);
        }
    }

    async info(...args: any[]): Promise<void> {
        const level = await this.getLogLevel();
        if (level === LogLevel.Debug) {
            console.log(...args);
        }
    }

    async debug(...args: any[]): Promise<void> {
        const level = await this.getLogLevel();
        if (level === LogLevel.Debug) {
            console.log('DEBUG:', ...args);
        }
    }
}

export const logger = new Logger();

----
manifest.json
{
	"manifest_version": 1,
	"id": "jp.emotiongraphics.omnivore-sync",
	"app_min_version": "2.13",
	"version": "0.2.1",
	"name": "Omnivore Sync",
	"description": "Sync articles and highlights from Omnivore to Joplin",
	"author": "Rino",
	"homepage_url": "https://github.com/rinodrops/joplin-plugin-omnivore-sync",
	"repository_url": "https://github.com/rinodrops/joplin-plugin-omnivore-sync",
	"keywords": ["omnivore", "sync"],
	"categories": ["productivity"],
	"screenshots": []
}

----
index.ts
// index.ts
// Aug 2024 by Rino, eMotionGraphics Inc.

import joplin from 'api';
import { setTimeout } from 'timers/promises';
import { MenuItemLocation, SettingItemType } from 'api/types';
import { OmnivoreClient } from './api/omnivore';
import { syncArticles, cleanupOldArticles } from './sync/article';
import { syncHighlights, cleanupHighlightNotes } from './sync/highlight';
import TurndownService from 'turndown';
import { logger, LogLevel } from './logger';
import { SyncType } from './types';

const turndownService = new TurndownService({
    headingStyle: 'atx',
    codeBlockStyle: 'fenced'
});

// Custom rule to handle headings
turndownService.addRule('heading', {
    filter: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
    replacement: function(content, node, options) {
        const hLevel = Number(node.nodeName.charAt(1));
        const cleanContent = content.replace(/\[]\([^)]+\)/g, '');
        return '\n\n' + '#'.repeat(hLevel) + ' ' + cleanContent.trim() + '\n\n';
    }
});

joplin.plugins.register({
    onStart: async function() {
        await joplin.settings.registerSection('omnivoreSync', {
            label: 'Omnivore Sync',
            iconName: 'fas fa-sync'
        });

        await joplin.settings.registerSettings({
            'omnivoreApiKey': {
                value: '',
                type: SettingItemType.String,
                section: 'omnivoreSync',
                public: true,
                label: 'Omnivore API Key'
            },
            'syncType': {
                value: SyncType.All,
                type: SettingItemType.String,
                section: 'omnivoreSync',
                public: true,
                label: 'Sync Type',
                description: 'Choose what to sync from Omnivore',
                isEnum: true,
                options: {
                    'all': 'Articles, highlights and annotations',
                    'articles': 'Articles only',
                    'highlights': 'Highlights and annotations only'
                }
            },
            'syncInterval': {
                value: 0,
                type: SettingItemType.Int,
                section: 'omnivoreSync',
                public: true,
                label: 'Sync Interval (minutes)',
                description: '0 for manual sync only'
            },
            'targetNotebook': {
                value: 'Omnivore',
                type: SettingItemType.String,
                section: 'omnivoreSync',
                public: true,
                label: 'Target Notebook',
                description: 'Name of the notebook to sync Omnivore articles to'
            },
            'articleLabels': {
                value: '',
                type: SettingItemType.String,
                section: 'omnivoreSync',
                public: true,
                label: 'Article Labels',
                description: 'Comma-separated list of labels for articles to sync (leave empty to sync all)'
            },
            'highlightLabels': {
                value: '',
                type: SettingItemType.String,
                section: 'omnivoreSync',
                public: true,
                label: 'Highlight Labels',
                description: 'Comma-separated list of labels for highlights to sync (leave empty to sync all)'
            },
            'highlightGrouping': {
                value: 'byDate',
                type: SettingItemType.String,
                section: 'omnivoreSync',
                public: true,
                label: 'Highlight Grouping',
                description: 'Choose how to group highlights',
                isEnum: true,
                options: {
                    'byDate': 'By Date',
                    'byArticle': 'By Article'
                }
            },
            'highlightTemplateChoice': {
                value: 'default',
                type: SettingItemType.String,
                section: 'omnivoreSync',
                public: true,
                label: 'Highlight Template',
                description: 'Choose the template for formatting highlights',
                isEnum: true,
                options: {
                    default: 'Default',
                    titleQuote: 'Title, Highlight and Note',
                    quoteOnly: 'Highlight and Note',
                }
            },
            'userTimezone': {
                value: 'local',
                type: SettingItemType.String,
                section: 'omnivoreSync',
                public: true,
                label: 'Your Timezone',
                description: 'Enter your timezone (e.g., "America/New_York", "Europe/London", or "local" for system timezone)'
            },
            'highlightSyncPeriod': {
                value: 14,
                type: SettingItemType.Int,
                section: 'omnivoreSync',
                public: true,
                label: 'Highlight Sync Period (days)',
                description: 'Number of days to look back for new highlights'
            },
            'highlightTitlePrefix': {
                value: 'Omnivore Highlights',
                type: SettingItemType.String,
                section: 'omnivoreSync',
                public: true,
                label: 'Highlight Note Title Prefix',
                description: 'Prefix for the title of highlight notes (followed by the date)'
            },
            'lastSyncDate': {
                value: '',
                type: SettingItemType.String,
                section: 'omnivoreSync',
                public: false,
                label: 'Last Sync Date'
            },
            'syncedArticles': {
                value: '[]',
                type: SettingItemType.String,
                section: 'omnivoreSync',
                public: false,
                label: 'Synced Articles'
            },
            'syncedHighlights': {
                value: '{}',
                type: SettingItemType.String,
                section: 'omnivoreSync',
                public: false,
                label: 'Synced Highlights',
                description: 'Internal use: Stores information about synced highlights'
            },
            'logLevel': {
                value: LogLevel.ErrorsAndWarnings,
                type: SettingItemType.String,
                section: 'omnivoreSync',
                public: true,
                label: 'Log Level',
                description: 'Set the level of logging detail',
                isEnum: true,
                options: {
                    [LogLevel.ErrorOnly]: 'Errors only',
                    [LogLevel.ErrorsAndWarnings]: 'Errors and Warnings',
                    [LogLevel.Debug]: 'Debug (verbose)'
                }
            },
        });

        await joplin.commands.register({
            name: 'resetOmnivoreSyncData',
            label: 'Reset Omnivore Sync Data',
            execute: async () => {
                const result = await joplin.views.dialogs.showMessageBox('Are you sure you want to reset the Omnivore Sync internal data? This will clear the last sync date and all synced article/highlight IDs (Notes are NOT deleted). The next sync will fetch all articles and highlights again.\n\nPress OK to confirm, or Cancel to abort.');

                if (result === 0) { // User clicked 'OK'
                    await joplin.settings.setValue('lastSyncDate', '');
                    await joplin.settings.setValue('syncedArticles', '[]');
                    await joplin.settings.setValue('syncedHighlights', '{}');
                    await logger.debug('Omnivore sync data has been reset.');
                    await joplin.views.dialogs.showMessageBox('Omnivore sync data has been reset. The next sync will fetch all articles and highlights.');
                } else {
                    await logger.debug('Reset operation cancelled by user.');
                }
            }
        });

        await joplin.commands.register({
            name: 'syncOmnivoreArticles',
            label: 'Sync Omnivore Articles',
            execute: async () => {
                const apiKey = await joplin.settings.value('omnivoreApiKey');
                if (!apiKey) {
                    await logger.error('Omnivore API key not set. Please set your API key in the plugin settings.');
                    return;
                }
                const client = new OmnivoreClient({ apiKey, baseUrl: 'https://api-prod.omnivore.app' });
                await performSync(client);
            },
        });

        await joplin.views.menuItems.create('syncOmnivoreArticlesMenuItem', 'syncOmnivoreArticles', MenuItemLocation.Tools);
        await joplin.views.menuItems.create('resetOmnivoreSyncDataMenuItem', 'resetOmnivoreSyncData', MenuItemLocation.Tools);

        const setupScheduledSync = async () => {
            const interval = await joplin.settings.value('syncInterval');
            if (interval > 0) {
                setInterval(async () => {
                    const apiKey = await joplin.settings.value('omnivoreApiKey');
                    if (apiKey) {
                        const client = new OmnivoreClient({ apiKey, baseUrl: 'https://api-prod.omnivore.app' });
                        await performSync(client);
                    }
                }, interval * 60 * 1000);
            }
        };

        await setupScheduledSync();
        await joplin.settings.onChange(async () => {
            await setupScheduledSync();
        });

        await logger.debug('Omnivore Sync plugin started');
    }
});

async function performSync(client: OmnivoreClient) {
    await logger.info('Starting Omnivore sync');
    let lastSyncDate = await joplin.settings.value('lastSyncDate');
    const syncType = await joplin.settings.value('syncType') as SyncType;
    const highlightSyncPeriod = await joplin.settings.value('highlightSyncPeriod');
    const targetNotebook = await joplin.settings.value('targetNotebook');

    if (!lastSyncDate) {
        lastSyncDate = new Date(0).toISOString();
        await logger.info('Last sync date was reset or not set. Using earliest possible date.');
    }

    await logger.debug(`Last sync date: ${lastSyncDate}`);
    await logger.debug(`Sync type: ${syncType}`);

    try {
        // Check for the target folder and create it if it doesn't exist, with retry mechanism
        const targetFolder = await getOrCreateNotebook(targetNotebook);
        await logger.info(`Target folder confirmed: ${targetFolder.title} (ID: ${targetFolder.id})`);

        let newLastSyncDate = lastSyncDate;

        const articleLabels = (await joplin.settings.value('articleLabels') as string).split(',').map(label => label.trim()).filter(Boolean);
        const highlightLabels = (await joplin.settings.value('highlightLabels') as string).split(',').map(label => label.trim()).filter(Boolean);

        if (syncType === SyncType.All || syncType === SyncType.Articles) {
            const articleResult = await syncArticles(client, turndownService, lastSyncDate, articleLabels, targetFolder.id);
            newLastSyncDate = articleResult.newLastSyncDate;
            await joplin.settings.setValue('syncedArticles', JSON.stringify(articleResult.syncedArticles));
        }

        if (syncType === SyncType.All || syncType === SyncType.Highlights) {
            const highlightResult = await syncHighlights(client, turndownService, lastSyncDate, highlightSyncPeriod, highlightLabels, targetFolder.id);
            if (new Date(highlightResult.newLastSyncDate) > new Date(newLastSyncDate)) {
                newLastSyncDate = highlightResult.newLastSyncDate;
            }
            await joplin.settings.setValue('syncedHighlights', JSON.stringify(highlightResult.syncedHighlights));
        }

        await cleanupHighlightNotes();

        const syncedArticles = JSON.parse(await joplin.settings.value('syncedArticles') || '[]');
        const cleanedArticles = await cleanupOldArticles(syncedArticles);
        await joplin.settings.setValue('syncedArticles', JSON.stringify(cleanedArticles));

        await joplin.settings.setValue('lastSyncDate', newLastSyncDate);
        await logger.info(`Sync completed. New last sync date: ${newLastSyncDate}`);
    } catch (error) {
        await logger.error(`Error during sync: ${error.message}`);
    }
}

async function getOrCreateNotebook(notebookName: string, maxRetries = 5): Promise<any> {
    const sanitizedName = notebookName.trim();

    for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
            const folders = await joplin.data.get(['folders']);
            const existingFolder = folders.items.find(folder =>
                folder.title.toLowerCase() === sanitizedName.toLowerCase()
            );

            if (existingFolder) {
                await logger.info(`Found existing folder: ${sanitizedName}`);
                return existingFolder;
            } else if (attempt === 0) {
                // Only try to create the folder on the first attempt
                await logger.info(`Attempting to create folder: ${sanitizedName}`);
                await joplin.data.post(['folders'], null, { title: sanitizedName });
                // Don't return immediately, continue to next iteration to verify creation
            } else {
                await logger.warn(`Folder not found on attempt ${attempt + 1}: ${sanitizedName}`);
            }
        } catch (error) {
            await logger.error(`Error on attempt ${attempt + 1} for folder ${sanitizedName}: ${error.message}`);
        }

        // Exponential backoff
        const delay = Math.pow(2, attempt) * 1000; // 1s, 2s, 4s, 8s, 16s
        await logger.info(`Waiting ${delay}ms before retry...`);
        await setTimeout(delay);
    }

    throw new Error(`Failed to create or find folder ${sanitizedName} after ${maxRetries} attempts`);
}

----
api/omnivore.ts
// api/omnivore.ts
// Aug 2024 by Rino, eMotionGraphics Inc.

import { Omnivore, Item, Highlight as OmnivoreHighlight } from '@omnivore-app/api';
import { Article, Highlight, OmnivoreClientConfig } from '../types';
import { logger } from '../logger';

export class OmnivoreClient {
    private client: Omnivore;

    constructor(config: OmnivoreClientConfig) {
        this.client = new Omnivore(config);
    }

    async getArticles(since: string, labels: string[] = []): Promise < Article[] > {
        try {
            const sinceDate = since ? new Date(since).toISOString().split('T')[0] : '';
            await logger.debug(`Fetching articles since: ${sinceDate || 'the beginning'}`);

            let query = `${sinceDate ? `saved:${sinceDate}..*` : ''} sort:saved-asc`;
            if (labels.length > 0) {
                const labelQuery = labels.map(label => `label:"${label}"`).join(' OR ');
                query += ` (${labelQuery})`;
            }
            await logger.debug(`Using query: ${query}`);

            let allArticles: Article[] = [];
            let hasNextPage = true;
            let after: string | null = null;

            while (hasNextPage) {
                const response = await this.client.items.search({
                    after: after ? parseInt(after) : undefined,
                    first: 100,
                    query: query,
                    includeContent: true
                });

                if (!response.edges || response.edges.length === 0) {
                    break;
                }

                allArticles = allArticles.concat(response.edges.map(edge => {
                    const item = edge.node as Item;
                    return {
                        ...item,
                        hash: (item as any).hash,
                        createdAt: (item as any).createdAt || item.savedAt,
                        readingProgressAnchorIndex: (item as any).readingProgressAnchorIndex,
                        folder: (item as any).folder
                    } as Article;
                }));

                hasNextPage = response.pageInfo.hasNextPage;
                after = response.pageInfo.endCursor;

                await logger.debug(`Fetched ${allArticles.length} articles so far`);
            }

            await logger.debug(`Total articles fetched: ${allArticles.length}`);
            return allArticles;
        } catch (error) {
            await logger.error(`Error fetching articles from Omnivore: ${error.message}`);
            throw error;
        }
    }

    async getHighlights(since: string, syncPeriod: number, labels: string[] = []): Promise<Highlight[]> {
        try {
            const sinceDate = new Date(since);
        const oldestDate = new Date();
        oldestDate.setDate(oldestDate.getDate() - syncPeriod);

        const queryDate = oldestDate < sinceDate ? oldestDate : sinceDate;
        const formattedDate = queryDate.toISOString().split('T')[0];

        await logger.debug(`Fetching highlights for articles saved since: ${formattedDate}`);

        let query = `saved:${formattedDate}..* sort:saved-asc has:highlights`;
        if (labels.length > 0) {
            const labelQuery = labels.map(label => `label:"${label}"`).join(' OR ');
            query += ` (${labelQuery})`;
        }
        await logger.debug(`Using query: ${query}`);


            let allHighlights: Highlight[] = [];
            let hasNextPage = true;
            let after: string | null = null;

            while (hasNextPage) {
                const response = await this.client.items.search({
                    after: after ? parseInt(after) : undefined,
                    first: 100,
                    query: query,
                    includeContent: true
                });

                if (!response.edges || response.edges.length === 0) {
                    break;
                }

                const highlights = response.edges.flatMap(edge => {
                    if (edge.node.highlights) {
                        return edge.node.highlights.map(highlight => {
                            const omnivoreHighlight = highlight as OmnivoreHighlight;
                            return {
                                ...omnivoreHighlight,
                                shortId: (omnivoreHighlight as any).shortId,
                                createdAt: (omnivoreHighlight as any).createdAt || new Date().toISOString(),
                                article: {
                                    id: edge.node.id,
                                    title: edge.node.title,
                                    url: edge.node.url,
                                    originalArticleUrl: edge.node.originalArticleUrl,
                                    savedAt: edge.node.savedAt,
                                    author: edge.node.author,
                                    publishedAt: edge.node.publishedAt,
                                    slug: edge.node.slug
                                }
                            } as Highlight;
                        });
                    }
                    return [];
                });

                allHighlights = allHighlights.concat(highlights);

                hasNextPage = response.pageInfo.hasNextPage;
                after = response.pageInfo.endCursor;

                await logger.debug(`Fetched ${allHighlights.length} highlights so far`);
            }

            await logger.debug(`Total highlights fetched: ${allHighlights.length}`);
            return allHighlights;
        } catch (error) {
            await logger.error(`Error fetching highlights from Omnivore: ${error.message}`);
            throw error;
        }
    }
}

----
sync/article.ts
// sync/article.ts
// Aug 2024 by Rino, eMotionGraphics Inc.

import joplin from 'api';
import TurndownService from 'turndown';
import { Article, SyncedArticle } from '../types';
import { OmnivoreClient } from '../api/omnivore';
import { logger } from '../logger';

export async function syncArticles(client: OmnivoreClient, turndownService: TurndownService, lastSyncDate: string, labels: string[], targetFolderId: string): Promise<{newLastSyncDate: string, syncedArticles: SyncedArticle[]}> {
    const articles = await client.getArticles(lastSyncDate, labels);
    await logger.debug(`Retrieved ${articles.length} articles from Omnivore`);

    let newLastSyncDate = lastSyncDate;
    let syncedArticles: SyncedArticle[] = JSON.parse(await joplin.settings.value('syncedArticles') || '[]');
    let newItemsCount = 0;

    for (const article of articles) {
        if (!syncedArticles.some(item => item.id === article.id)) {
            await syncArticleToJoplin(article, turndownService, targetFolderId);
            syncedArticles.push({ id: article.id, savedAt: article.savedAt });
            newItemsCount++;
            if (new Date(article.savedAt) > new Date(newLastSyncDate)) {
                newLastSyncDate = article.savedAt;
            }
        }
    }

    await logger.info(`Synced ${newItemsCount} new articles from Omnivore.`);
    return { newLastSyncDate, syncedArticles };
}

async function syncArticleToJoplin(article: Article, turndownService: TurndownService, targetFolderId: string) {
    await logger.debug(`Syncing new article: ${article.title}`);
    try {
        const markdown = turndownService.turndown(article.content);

        await joplin.data.post(['notes'], null, {
            parent_id: targetFolderId,
            title: article.title,
            body: markdown,
            author: 'Omnivore Sync',
            source_url: article.url,
            tags: article.labels ? article.labels.map(label => label.name).join(',') : ''
        });
        await logger.debug(`Successfully synced article: ${article.title}`);
    } catch (error) {
        await logger.error(`Error syncing article ${article.title}: ${error.message}`);
    }
}

export async function cleanupOldArticles(syncedArticles: SyncedArticle[]): Promise<SyncedArticle[]> {
    await logger.debug('Starting cleanup process for articles');
    try {
        const thresholdDate = new Date();
        thresholdDate.setDate(thresholdDate.getDate() - 3);

        const recentArticles = syncedArticles.filter(item => {
            const itemSavedAt = new Date(item.savedAt);
            return itemSavedAt >= thresholdDate;
        });

        await logger.debug(`Cleaned up synced articles. Kept ${recentArticles.length} out of ${syncedArticles.length}`);
        return recentArticles;
    } catch (error) {
        await logger.error(`Error in cleanupOldArticles: ${error.message}`);
        return syncedArticles; // Return original array if there's an error
    }
}

----
sync/highlight.ts
// sync/highlight.ts
// Sep 2024 by Rino, eMotionGraphics Inc.

import joplin from 'api';
import TurndownService from 'turndown';
import { DateTime } from 'luxon';
import * as Mustache from 'mustache';
import { Highlight } from '../types';
import { OmnivoreClient } from '../api/omnivore';
import { logger } from '../logger';

const HIGHLIGHT_TEMPLATES = {
    default: `
**{{article.title}}**

> {{quote}}{{#annotation}}
> **Note**: {{annotation}}{{/annotation}}
> ({{createdAt}})

**Author**: {{article.author}}
**Published**: {{article.publishedAt}}
**URL**: [Omnivore]({{article.omnivoreUrl}}), [Original]({{article.originalArticleUrl}})
    `,
    titleQuote: `
[{{article.title}}]({{article.omnivoreUrl}})
> {{quote}}{{#annotation}}
> **Note**: {{annotation}}{{/annotation}}
> ({{createdAt}})
    `,
    quoteOnly: `
> {{quote}}{{#annotation}}
> **Note**: {{annotation}}{{/annotation}}
> ({{createdAt}})
    `
};

export async function syncHighlights(client: OmnivoreClient, turndownService: TurndownService, lastSyncDate: string, syncPeriod: number, labels: string[], targetFolderId: string): Promise<{ newLastSyncDate: string, syncedHighlights: { [key: string]: string[] } }> {
    const highlights = await client.getHighlights(lastSyncDate, syncPeriod, labels);
    await logger.debug(`Retrieved ${highlights.length} highlights from Omnivore`);

    const userTimezone = await joplin.settings.value('userTimezone') || 'local';
    let syncedHighlights: { [key: string]: string[] } = JSON.parse(await joplin.settings.value('syncedHighlights') || '{}');
    const highlightGrouping = await joplin.settings.value('highlightGrouping');

    let newLastSyncDate = lastSyncDate;
    let newItemsCount = 0;

    // Group highlights based on the chosen grouping method
    const groupedHighlights = groupHighlights(highlights, highlightGrouping, userTimezone);

    // Cache to store notes we've already created or found during this sync
    const noteCache: { [key: string]: any } = {};

    for (const [groupKey, groupHighlights] of Object.entries(groupedHighlights)) {
        await syncGroupedHighlights(groupKey, groupHighlights, syncedHighlights, turndownService, userTimezone, highlightGrouping, targetFolderId, noteCache);

        newItemsCount += groupHighlights.length;
        const latestHighlightDate = groupHighlights.reduce((latest, highlight) => {
            return new Date(highlight.createdAt) > new Date(latest) ? highlight.createdAt : latest;
        }, lastSyncDate);

        if (new Date(latestHighlightDate) > new Date(newLastSyncDate)) {
            newLastSyncDate = latestHighlightDate;
        }
    }

    await joplin.settings.setValue('syncedHighlights', JSON.stringify(syncedHighlights));
    await logger.debug(`Synced ${newItemsCount} new highlights from Omnivore.`);

    return { newLastSyncDate, syncedHighlights };
}

function groupHighlights(highlights: Highlight[], groupingType: string, userTimezone: string): { [key: string]: Highlight[] } {
    const grouped: { [key: string]: Highlight[] } = {};

    for (const highlight of highlights) {
        let key;
        if (groupingType === 'byArticle') {
            key = highlight.article.id;
        } else { // byDate
            key = DateTime.fromISO(highlight.createdAt).setZone(userTimezone).toFormat('yyyy-MM-dd');
        }

        if (!grouped[key]) {
            grouped[key] = [];
        }
        grouped[key].push(highlight);
    }

    return grouped;
}

async function syncGroupedHighlights(groupKey: string, highlights: Highlight[], syncedHighlights: { [key: string]: string[] }, turndownService: TurndownService, userTimezone: string, groupingType: string, targetFolderId: string, noteCache: { [key: string]: any }) {
    const titlePrefix = await joplin.settings.value('highlightTitlePrefix');
    let noteTitle;

    if (groupingType === 'byArticle') {
        noteTitle = `${titlePrefix} - ${highlights[0].article.title}`;
    } else { // byDate
        noteTitle = `${titlePrefix} ${groupKey}`;
    }

    let existingNote;
    if (noteCache[groupKey]) {
        existingNote = noteCache[groupKey];
    } else {
        existingNote = await getOrCreateHighlightNote(noteTitle, targetFolderId);
        noteCache[groupKey] = existingNote;
    }

    if (groupingType === 'byArticle') {
        highlights.sort((a, b) => (a.highlightPositionPercent || 0) - (b.highlightPositionPercent || 0));
    } else { // byDate
        highlights.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
        highlights = groupHighlightsByArticle(highlights);
    }

    const highlightTemplate = await getHighlightTemplate();
    let newContent = '';
    for (const highlight of highlights) {
        if (!syncedHighlights[groupKey]) {
            syncedHighlights[groupKey] = [];
        }

        if (!syncedHighlights[groupKey].includes(highlight.id)) {
            const highlightContent = renderHighlightContent(highlight, highlightTemplate, userTimezone, turndownService);
            newContent += highlightContent + '\n\n---\n\n';
            syncedHighlights[groupKey].push(highlight.id);
        }
    }

    if (newContent) {
        await appendHighlightsToNote(existingNote.id, newContent.trim());
    }
}

function groupHighlightsByArticle(highlights: Highlight[]): Highlight[] {
    const articleGroups: { [key: string]: Highlight[] } = {};

    for (const highlight of highlights) {
        if (!articleGroups[highlight.article.id]) {
            articleGroups[highlight.article.id] = [];
        }
        articleGroups[highlight.article.id].push(highlight);
    }

    return Object.values(articleGroups).flat();
}

async function appendHighlightsToNote(noteId: string, newContent: string) {
    const note = await joplin.data.get(['notes', noteId], { fields: ['body'] });
    const updatedBody = note.body ? note.body + '\n\n' + newContent : newContent;
    await joplin.data.put(['notes', noteId], null, { body: updatedBody });
}

async function getOrCreateHighlightNote(title: string, targetFolderId: string): Promise<any> {
    const searchResult = await joplin.data.get(['search'], { query: `"${title}"`, fields: ['id', 'title', 'body'] });

    if (searchResult && Array.isArray(searchResult.items) && searchResult.items.length > 0) {
        // If multiple notes exist for the same day, merge them
        if (searchResult.items.length > 1) {
            return await mergeHighlightNotes(searchResult.items);
        }
        return searchResult.items[0];
    } else {
        return await joplin.data.post(['notes'], null, {
            parent_id: targetFolderId,
            title: title,
            body: ''
        });
    }
}


async function mergeHighlightNotes(notes: any[]): Promise < any > {
    const mergedBody = notes.map(note => note.body).join('\n\n---\n\n');
    const firstNote = notes[0];
    await joplin.data.put(['notes', firstNote.id], null, { body: mergedBody, title: firstNote.title });

    // Delete other notes
    for (let i = 1; i < notes.length; i++) {
        await joplin.data.delete(['notes', notes[i].id]);
    }

    await logger.debug(`Merged ${notes.length} notes for ${firstNote.title}`);
    return firstNote;
}

async function appendHighlightToNote(noteId: string, newHighlightContent: string, highlightId: string) {
    await logger.debug(`Appending highlight ${highlightId} to note ${noteId}`);
    const note = await joplin.data.get(['notes', noteId], { fields: ['body'] });
    let highlights = note.body ? note.body.split('\n\n---\n\n').filter(h => h.trim() !== '') : [];
    await logger.debug(`Existing highlights in note: ${highlights.length}`);

    // Decode HTML entities in the new highlight content
    newHighlightContent = decodeHtmlEntities(newHighlightContent);

    // Extract creation time and a portion of the content for comparison
    const newHighlightCreationTime = newHighlightContent.match(/\((\d{4}-\d{2}-\d{2} \d{2}:\d{2})\)/)?.[1] || '';
    const newHighlightFirstLine = newHighlightContent.split('\n')[0];

    // Check if the highlight already exists in the note
    const exists = highlights.some(h => {
        const existingCreationTime = h.match(/\((\d{4}-\d{2}-\d{2} \d{2}:\d{2})\)/)?.[1] || '';
        const existingFirstLine = h.split('\n')[0];
        return existingCreationTime === newHighlightCreationTime && existingFirstLine === newHighlightFirstLine;
    });

    if (!exists) {
        highlights.push(newHighlightContent);
        await logger.debug(`New highlight ${highlightId} added to the list`);
    } else {
        await logger.debug(`Highlight ${highlightId} already exists in the note, skipping`);
    }

    // Sort highlights by their creation time
    highlights.sort((a, b) => {
        const getCreationTime = (highlight) => {
            const match = highlight.match(/\((\d{4}-\d{2}-\d{2} \d{2}:\d{2})\)/);
            return match ? match[1] : '';
        };
        return getCreationTime(b).localeCompare(getCreationTime(a)); // Reverse sort (newest first)
    });

    const updatedBody = highlights.join('\n\n---\n\n');
    await joplin.data.put(['notes', noteId], null, { body: updatedBody });

    await logger.debug(`Updated note ${noteId}. Total highlights after update: ${highlights.length}`);
}

async function getHighlightTemplate(): Promise < string > {
    const choice = await joplin.settings.value('highlightTemplateChoice');
    return HIGHLIGHT_TEMPLATES[choice].trim();
}

function renderHighlightContent(highlight: Highlight, template: string, userTimezone: string, turndownService: TurndownService): string {
    let omnivoreUrl = 'https://omnivore.app/me/';
    if (highlight.article.slug) {
        omnivoreUrl += highlight.article.slug;
    } else if (highlight.article.id) {
        omnivoreUrl += highlight.article.id;
    } else {
        omnivoreUrl += highlight.id;
    }

    return Mustache.render(template, {
        article: {
            title: decodeHtmlEntities(highlight.article.title),
            author: decodeHtmlEntities(highlight.article.author || 'Unknown'),
            publishedAt: highlight.article.publishedAt ?
                DateTime.fromISO(highlight.article.publishedAt).setZone(userTimezone).toFormat('yyyy-MM-dd HH:mm') : 'Unknown',
            omnivoreUrl: decodeHtmlEntities(omnivoreUrl),
            originalArticleUrl: decodeHtmlEntities(highlight.article.originalArticleUrl || highlight.article.url)
        },
        quote: decodeHtmlEntities(turndownService.turndown(highlight.quote)),
        annotation: highlight.annotation ? decodeHtmlEntities(turndownService.turndown(highlight.annotation)) : null,
        createdAt: DateTime.fromISO(highlight.createdAt).setZone(userTimezone).toFormat('yyyy-MM-dd HH:mm')
    });
}

async function getOrCreateNotebook(notebookName: string): Promise < any > {
    const folders = await joplin.data.get(['folders']);
    const existingFolder = folders.items.find(folder => folder.title === notebookName);
    if (existingFolder) {
        return existingFolder;
    } else {
        return await joplin.data.post(['folders'], null, { title: notebookName });
    }
}

export async function cleanupHighlightNotes() {
    const titlePrefix = await joplin.settings.value('highlightTitlePrefix');
    const searchQuery = `${titlePrefix}*`;
    const searchResult = await joplin.data.get(['search'], { query: searchQuery, fields: ['id', 'title', 'body'] });
    if (!searchResult || !Array.isArray(searchResult.items)) {
        await logger.debug('No highlight notes found or invalid search result');
        return;
    }

    const highlightNotes = searchResult.items;
    const notesByDate: {
        [key: string]: any[] } = {};

    for (const note of highlightNotes) {
        const datePart = note.title.replace(`${titlePrefix} `, '');
        if (!notesByDate[datePart]) {
            notesByDate[datePart] = [];
        }
        notesByDate[datePart].push(note);
    }

    for (const [date, notes] of Object.entries(notesByDate)) {
        if (notes.length > 1) {
            await mergeHighlightNotes(notes);
        }
    }
}

export function decodeHtmlEntities(text: string): string {
    const entities = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'"
    };
    return text.replace(/&#x([0-9A-Fa-f]+);/g, (match, dec) => String.fromCharCode(parseInt(dec, 16)))
        .replace(/&[#A-Za-z0-9]+;/g, entity => entities[entity] || entity);
}

--END--